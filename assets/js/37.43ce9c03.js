(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{380:function(_,v,a){"use strict";a.r(v);var t=a(4),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"chapter-2-리팩터링-원칙"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2-리팩터링-원칙"}},[_._v("#")]),_._v(" Chapter 2. 리팩터링 원칙")]),_._v(" "),a("h3",{attrs:{id:"_1-리팩터링-정의"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-리팩터링-정의"}},[_._v("#")]),_._v(" 1. 리팩터링 정의")]),_._v(" "),a("h4",{attrs:{id:"명사"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#명사"}},[_._v("#")]),_._v(" 명사")]),_._v(" "),a("ul",[a("li",[_._v("소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법\n"),a("ul",[a("li",[_._v("1장에서 함수 추출, 조건부 로직 다형성으로 변경하는 것들이 여기에 속한다.")])])])]),_._v(" "),a("h4",{attrs:{id:"동사"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#동사"}},[_._v("#")]),_._v(" 동사")]),_._v(" "),a("ul",[a("li",[_._v("소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성")])]),_._v(" "),a("blockquote",[a("p",[_._v('누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링 한것이 아니다.')])]),_._v(" "),a("ul",[a("li",[_._v("리팩터링 하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든지 멈출 수 있어야 한다.")]),_._v(" "),a("li",[_._v("리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. "),a("strong",[_._v("단지 목적이 다를 뿐이다.")])]),_._v(" "),a("li",[_._v("리팩토링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것으로 성능은 나빠질 수도 좋아질 수도 있다.")])]),_._v(" "),a("h3",{attrs:{id:"_2-두-개의-모자"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-두-개의-모자"}},[_._v("#")]),_._v(" 2. 두 개의 모자")]),_._v(" "),a("ul",[a("li",[_._v("개발 시 목적이 '기능 추가'냐 '리팩터링'인지를 두 개의 모자로 비유 한다.")]),_._v(" "),a("li",[_._v("기능 추가 시 기눙 추가 모자를 쓴 후 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.\n"),a("ul",[a("li",[_._v("진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 진행한다.")])])]),_._v(" "),a("li",[_._v("리팩터링 시는 기능 추가는 절대 하지 않고 오로지 코드 재구성에 전념한다.\n"),a("ul",[a("li",[_._v("테스드도 새로 만들지 않고 기존 테스트를 실행시킨다.(인터페이스 변경이 필요해지면 테스트 수정이 필요해짐)")])])])]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("작업 시간이 10분이라고 해도 항상 쓰고 있는 모자가 무엇인지, 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.")])])]),_._v(" "),a("h3",{attrs:{id:"_3-리팩터링하는-이유"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-리팩터링하는-이유"}},[_._v("#")]),_._v(" 3. 리팩터링하는 이유")]),_._v(" "),a("h4",{attrs:{id:"소프트웨어-설계가-좋아진다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#소프트웨어-설계가-좋아진다"}},[_._v("#")]),_._v(" 소프트웨어 설계가 좋아진다.")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링을 하지 않으면 소프트웨어의 내부 설계가 썩기 쉽다.")]),_._v(" "),a("li",[_._v("아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.")]),_._v(" "),a("li",[a("strong",[_._v("규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.")])])]),_._v(" "),a("h4",{attrs:{id:"소프트웨어를-이해하기-쉬워진다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#소프트웨어를-이해하기-쉬워진다"}},[_._v("#")]),_._v(" 소프트웨어를 이해하기 쉬워진다.")]),_._v(" "),a("ul",[a("li",[_._v("컴퓨터는 시키는 일을 정확히 하므로 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.")])]),_._v(" "),a("h4",{attrs:{id:"버그를-쉽게-찾을-수-있다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#버그를-쉽게-찾을-수-있다"}},[_._v("#")]),_._v(" 버그를 쉽게 찾을 수 있다.")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.")]),_._v(" "),a("li",[_._v("프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점이 분명히 드러나 버그를 놓칠 수 없을 만큼 명확해진다.")])]),_._v(" "),a("h4",{attrs:{id:"프로그래밍-속도를-높일-수-있다"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#프로그래밍-속도를-높일-수-있다"}},[_._v("#")]),_._v(" 프로그래밍 속도를 높일 수 있다.")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링을 하면 코드의 구조가 개선돼 사실상 프로그래밍 시간을 줄일 수 있다.")]),_._v(" "),a("li",[_._v("모듈화가 잘 되어 있으면 필요한 부분만 이해하면 되고, 코드가 명확하면 버그 가능성이 줄어들며 디버깅이 수월해진다.")]),_._v(" "),a("li",[_._v("내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.")]),_._v(" "),a("li",[_._v("지구력 가설\n"),a("ul",[a("li",[_._v("내부 설계에 심혀을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.")])])])]),_._v(" "),a("h3",{attrs:{id:"_4-언제-리팩터링을-해야-할까"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-언제-리팩터링을-해야-할까"}},[_._v("#")]),_._v(" 4. 언제 리팩터링을 해야 할까?")]),_._v(" "),a("h4",{attrs:{id:"_3의-법칙"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3의-법칙"}},[_._v("#")]),_._v(" 3의 법칙")]),_._v(" "),a("ul",[a("li",[a("ol",[a("li",[_._v("처음엔 그냥 한다.")])])]),_._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[_._v("비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.")])])]),_._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[_._v("비슷한 일을 세 번째 하게되면 리팩터링 한다.")])])])]),_._v(" "),a("h4",{attrs:{id:"준비를-위한-리팩터링-기능을-쉽게-추가하게-만들기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#준비를-위한-리팩터링-기능을-쉽게-추가하게-만들기"}},[_._v("#")]),_._v(" 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.")]),_._v(" "),a("li",[_._v("이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꿔 다른 작업을 하기가 쉬워질 부분들을 찾는다.")]),_._v(" "),a("li",[_._v("버그를 잡을 때도, 오류를 일으키는 코드가 여러곳 퍼져있다면 한 곳으로 합치는 편이 효율적이다.")])]),_._v(" "),a("h4",{attrs:{id:"이해를-위한-리팩터링-코드를-이해하기-쉽게-만들기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#이해를-위한-리팩터링-코드를-이해하기-쉽게-만들기"}},[_._v("#")]),_._v(" 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기")]),_._v(" "),a("ul",[a("li",[_._v("코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리패터링할 여지는 없는지 찾아보자.")]),_._v(" "),a("li",[_._v("이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없다.")])]),_._v(" "),a("h4",{attrs:{id:"쓰레기-줍기-리팩터링"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#쓰레기-줍기-리팩터링"}},[_._v("#")]),_._v(" 쓰레기 줍기 리팩터링")]),_._v(" "),a("ul",[a("li",[_._v("코드를 파악하던 중 비효율적으로 구성된 코드들이 있는데 이 작업에 많은 시간을 쏟을 수 없을 때 조금이라도 개선을 하는 것이다.")]),_._v(" "),a("li",[_._v("항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.")]),_._v(" "),a("li",[a("strong",[_._v("리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다")])])]),_._v(" "),a("h4",{attrs:{id:"계획된-리팩터링과-수시로-하는-리팩터링"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#계획된-리팩터링과-수시로-하는-리팩터링"}},[_._v("#")]),_._v(" 계획된 리팩터링과 수시로 하는 리팩터링")]),_._v(" "),a("ul",[a("li",[_._v("위에서 설명한 리팩터링은 기회가 될 때만 진행한다.")]),_._v(" "),a("li",[_._v("리팩터링 일정을 따로 잡지 않고 기능 추가, 버그 해결중에 리팩터링을 진행한다.")]),_._v(" "),a("li",[_._v("리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.")])]),_._v(" "),a("blockquote",[a("p",[_._v("보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.")])]),_._v(" "),a("blockquote",[a("p",[_._v("무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그 후에 수정하자.")])]),_._v(" "),a("ul",[a("li",[_._v("새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길이다.")]),_._v(" "),a("li",[_._v("계획된 리팩터링이 무조건 나쁘진 않지만 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.")])]),_._v(" "),a("h4",{attrs:{id:"오래-걸리는-리팩터링"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#오래-걸리는-리팩터링"}},[_._v("#")]),_._v(" 오래 걸리는 리팩터링")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간이다.")]),_._v(" "),a("li",[_._v("하지만 몇 주씩 걸리는 대규모 리팩터링도 있다. 라이브러리를 새것으로 교체하거나, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내거나 등..")]),_._v(" "),a("li",[_._v("리팩터링이 코드를 깨트리지 않는다는 장점을 활용하여 팀 전체가 매달리기 보다, 누구든지 리팩터링해야할 코드와 관련된 작업을 할 때마다 리팩터링을 통해 조금씩 원하는 방향으로 개선하자.")])]),_._v(" "),a("h4",{attrs:{id:"코드-리뷰에-리팩터링-활용하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#코드-리뷰에-리팩터링-활용하기"}},[_._v("#")]),_._v(" 코드 리뷰에 리팩터링 활용하기")]),_._v(" "),a("ul",[a("li",[_._v("가능하면 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링한다. 이렇게 자연스럽게 "),a("strong",[_._v("짝 프로그래밍")]),_._v("이 된다.")])]),_._v(" "),a("h4",{attrs:{id:"리팩터링-하지-말아야-할-때"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#리팩터링-하지-말아야-할-때"}},[_._v("#")]),_._v(" 리팩터링 하지 말아야 할 때")]),_._v(" "),a("ul",[a("li",[_._v("외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.")]),_._v(" "),a("li",[_._v("내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있따.")]),_._v(" "),a("li",[_._v("리팩터링보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링하지 않는다.")])]),_._v(" "),a("h3",{attrs:{id:"_5-리팩터링-시-고려할-문제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-리팩터링-시-고려할-문제"}},[_._v("#")]),_._v(" 5. 리팩터링 시 고려할 문제")]),_._v(" "),a("h4",{attrs:{id:"새-기능-개발-속도-저하"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#새-기능-개발-속도-저하"}},[_._v("#")]),_._v(" 새 기능 개발 속도 저하")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.")])]),_._v(" "),a("li",[_._v("리팩터링을 '클린 코드', '바람직한 엔지니어링 습관'처럼 도덕적인 이류로 정당화하는게 아닌 오직 경제적인 이유로 하여야 한다.")]),_._v(" "),a("li",[_._v("리팩터링은 개발 기간을 단축하고자 하는 것이며 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.")])]),_._v(" "),a("h4",{attrs:{id:"코드-소유권"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#코드-소유권"}},[_._v("#")]),_._v(" 코드 소유권")]),_._v(" "),a("ul",[a("li",[_._v("코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 코드 소유권은 팀에 두고 팀원 누구나 팀의 코드를 수정할 수 있게 한다.")])]),_._v(" "),a("h4",{attrs:{id:"브랜치"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#브랜치"}},[_._v("#")]),_._v(" 브랜치")]),_._v(" "),a("ul",[a("li",[_._v("브랜치를 기능별로 분리하여 마스터로 통합하는 방식은 효율적일 수 있지만 리팩터링에는 잘 어울리지 못한다.")]),_._v(" "),a("li",[_._v("가능한 통합 주기를 짧게하여 통합 시 코드의 문제 발생을 최대한 적게 하도록 한다.")])]),_._v(" "),a("h4",{attrs:{id:"테스팅"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#테스팅"}},[_._v("#")]),_._v(" 테스팅")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링은 단계별 변경 폭이 작아 도중에 발생한 오류의 원인이 될만한 코드의 범위가 넓지 않다.")]),_._v(" "),a("li",[_._v("원인을 못 찾더라도 기능에 변경은 없으니 이전 버전으로 돌리면된다.")]),_._v(" "),a("li",[_._v("오류를 재빨리 잡기 위해 가장 효율적인건 테스트이다. 변경이 잦은 리팩터링을 하기 위해선 테스트가 매우 중요하다.")])]),_._v(" "),a("h4",{attrs:{id:"레거시-코드"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#레거시-코드"}},[_._v("#")]),_._v(" 레거시 코드")]),_._v(" "),a("ul",[a("li",[_._v("레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.")]),_._v(" "),a("li",[_._v("레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다.")]),_._v(" "),a("li",[_._v("제 기능이 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬는다.")]),_._v(" "),a("li",[_._v("대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.")]),_._v(" "),a("li",[_._v("테스트 코드가 없다면 테스트를 보강하자.")])]),_._v(" "),a("h3",{attrs:{id:"_6-리팩터링-아키텍처-애그니-yagni"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-리팩터링-아키텍처-애그니-yagni"}},[_._v("#")]),_._v(" 6. 리팩터링, 아키텍처, 애그니(YAGNI)")]),_._v(" "),a("ul",[a("li",[_._v("리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.")]),_._v(" "),a("li",[_._v("리팩터링은 어느 부분에 유연성이 필요하고 어떻게 잘 대응할지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다.")]),_._v(" "),a("li",[_._v("이런식의 설계를 '간결한 설계', '점진적 설계', 'YAGNI(You aren't going to need it) 등으로 부른다.")]),_._v(" "),a("li",[_._v("YAGNI를 한다고 선제적인 아키텍처를 소홀히 해도 된다는건 아니다. 다만 이 둘 사이의 균형점이 이전과 크게 달라졌다.")])]),_._v(" "),a("h3",{attrs:{id:"_7-리팩터링과-소프트웨어-개발-프로세스"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-리팩터링과-소프트웨어-개발-프로세스"}},[_._v("#")]),_._v(" 7. 리팩터링과 소프트웨어 개발 프로세스")]),_._v(" "),a("ul",[a("li",[_._v("익스트림 프로그래밍(XP)의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 상호 의존하는 기법들을 하나로 묶은 프로세스라고 할 수 있다.")]),_._v(" "),a("li",[_._v("지속적 통합, 자가 테스트 코드, 리팩터링을 적용하면 YAGNI 설계를 진행할 수 있다. 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다.")]),_._v(" "),a("li",[_._v("추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽기 때문이다.")])]),_._v(" "),a("h3",{attrs:{id:"_8-리팩터링과-성능"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-리팩터링과-성능"}},[_._v("#")]),_._v(" 8. 리팩터링과 성능")]),_._v(" "),a("ul",[a("li",[_._v("직관적인 설계 vs 성능은 중요한 주제다.")]),_._v(" "),a("li",[_._v("리팩터링하면 소프트웨어가 느려질 수 있는건 사실이다.")]),_._v(" "),a("li",[_._v("하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.")]),_._v(" "),a("li",[_._v("hard real-time 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, "),a("strong",[_._v("먼저 튜닝하기 쉽게 만들고")]),_._v(" 나서 원하는 속도가 나게끔 튜닝하는 것이다.")]),_._v(" "),a("li",[a("strong",[_._v("그 후 끊임없이 관심을 기울인다.")]),_._v(" 프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다.")]),_._v(" "),a("li",[_._v("성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발은 더뎌진다.")]),_._v(" "),a("li",[_._v("성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다.")]),_._v(" "),a("li",[_._v("그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없을 것이므로 시간 낭비인 셈이다.")]),_._v(" "),a("li",[_._v("90%의 시간 낭비에 착안하여 성능 개선의 3번째 방법은 "),a("strong",[_._v("의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);