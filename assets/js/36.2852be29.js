(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{378:function(t,_,a){"use strict";a.r(_);var s=a(5),v=Object(s.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"chapter-1-리팩터링-첫-번째-예시"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-1-리팩터링-첫-번째-예시"}},[t._v("#")]),t._v(" Chapter 1. 리팩터링: 첫 번째 예시")]),t._v(" "),a("h3",{attrs:{id:"_1-예시-프로그램"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-예시-프로그램"}},[t._v("#")]),t._v(" 1. 예시 프로그램")]),t._v(" "),a("ul",[a("li",[t._v("프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.")]),t._v(" "),a("li",[a("a",{attrs:{href:"step1.js"}},[t._v("step1")])])]),t._v(" "),a("h4",{attrs:{id:"_1-리팩터링-첫-단계"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-리팩터링-첫-단계"}},[t._v("#")]),t._v(" 1) 리팩터링 첫 단계")]),t._v(" "),a("ul",[a("li",[t._v("리팩터링 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼곰하게 검사해줄 테스트 코드를 만들어야 한다.")]),t._v(" "),a("li",[a("strong",[t._v("리팩터링하기 전에 제대로 된 테스트부터 마련하다. 테스트는 반드시 자가진단하도록 만든다.")])])]),t._v(" "),a("h4",{attrs:{id:"_2-statement-함수-쪼개기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-statement-함수-쪼개기"}},[t._v("#")]),t._v(" 2) statement() 함수 쪼개기")]),t._v(" "),a("ul",[a("li",[t._v("switch문은 한 번의 공연에 대한 요금을 계산하고 있다.")]),t._v(" "),a("li",[t._v("이러한 사실은 코드를 분석해서 얻은 정보로 이렇게 파악한 정보는 휘발성이 강하기 때문에 재빨리 코드에 반영해야 한다.")]),t._v(" "),a("li",[t._v("그러면 다음에 코드를 볼 때 다시 분석하지 않아도 코드 스스로가 자신이 하는일을 알려줄 수 있다. "),a("a",{attrs:{href:"step2.js"}},[t._v("step2")])]),t._v(" "),a("li",[a("strong",[t._v("리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.")])]),t._v(" "),a("li",[t._v("동적 타입 언어에선 변수명에 타입을 드러내게 하면 도움이된다. 역할이 뚜렷하지 않을 때는 부정 관사를 붙이면 좋다.")]),t._v(" "),a("li",[a("strong",[t._v("컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.")])])]),t._v(" "),a("h4",{attrs:{id:"_3-play변수-제거하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-play변수-제거하기"}},[t._v("#")]),t._v(" 3) play변수 제거하기")]),t._v(" "),a("ul",[a("li",[t._v("amountFor()의 매개변수 중 play는 사실 performance에서 얻는거이므로 따로 전달할 필요가 없다. "),a("a",{attrs:{href:"step3.js"}},[t._v("step3")])]),t._v(" "),a("li",[t._v("이로인해 공연을 조회 횟수가 1번에서 3번으로 증가하였다. 그렇다고해도 성능에 큰 영향은 없다.")]),t._v(" "),a("li",[t._v("설사 심각하게 느려지더라도 리팩터링된 코드베이스는 성능 개선이 수월하다.")])]),t._v(" "),a("blockquote",[a("p",[t._v("지역변수를 제거해서 얻는 가장 큰 장점은 유효범위를 신경 써야할 대상이 즐어들기 때문에 추출작업이 쉬워진다.")])]),t._v(" "),a("h4",{attrs:{id:"_4-적립-포인트-계산-코드-추출"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-적립-포인트-계산-코드-추출"}},[t._v("#")]),t._v(" 4) 적립 포인트 계산 코드 추출")]),t._v(" "),a("ul",[a("li",[t._v("volumeCredits은 반복문을 돌때마다 값을 누적해야하므로 volumesCredits의 복제본을 초기화해서 계산 결과를 반환하도록하는 것이 편리하다. "),a("a",{attrs:{href:"step4.js"}},[t._v("step4")])])]),t._v(" "),a("h4",{attrs:{id:"_5-format-변수-제거하기-volumecredits-totalamount-변수-제거-반복문-쪼개기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-format-변수-제거하기-volumecredits-totalamount-변수-제거-반복문-쪼개기"}},[t._v("#")]),t._v(" 5) format 변수 제거하기, volumeCredits, totalAmount 변수 제거(반복문 쪼개기)")]),t._v(" "),a("ul",[a("li",[t._v("임시 변수는 나중에 문제를 일으킬 수 있고, 자신이 속한 루틴에서만 의미가 있어 루틴이 길고 복잡해지기 쉽다.")]),t._v(" "),a("li",[t._v("따라서 다음 리팩터링은 이런 변수들을 제거하는 것이다.")]),t._v(" "),a("li",[t._v("반복문을 쪼개면 성능에 대해 걱정이 될 수 있겠지만 이 정도의 중복은 성능에 크게 영향을 미치지 않는다.")]),t._v(" "),a("li",[t._v("'특별한 경우가 아니라면 일단 무시하자'. 그리고 성능이 떨어진다면 리팩터링 후 다시 성능을 개선하자.")]),t._v(" "),a("li",[t._v("상황이 복잡해질 때는 아래와 같이 순서마다 커밋을 해서 문제가 발생하더라도 쉽게 복구할 수 있도록 하자.\n"),a("ul",[a("li",[t._v("반복문 쪼개기 -> 문장 슬라이스하기(변수 초기화 문장을 사용 코드 앞에 위치 시킴) -> 함수 추출하기 -> 변수 인라인 하기")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-계산-단계와-포맷팅-단계-분리하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-계산-단계와-포맷팅-단계-분리하기"}},[t._v("#")]),t._v(" 2. 계산 단계와 포맷팅 단계 분리하기")]),t._v(" "),a("ul",[a("li",[t._v("지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는데 주안점을 두고 리팩터링했다.")]),t._v(" "),a("li",[t._v("리팩터링 초기 단계에서 흔히 수행하는 일로 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.")]),t._v(" "),a("li",[t._v("이제 state()의 html 버전을 만드는 작업을 살펴보자.")]),t._v(" "),a("li",[t._v("텍스트와 html 버전 모두 똑같은 함수를 사용하게 하고 싶을 때 "),a("strong",[t._v("단위 쪼개기")]),t._v("를 이용하면 된다.")]),t._v(" "),a("li",[t._v("statement()를 두 단계로 나누어서 첫 단계에서는 statement()에 필요한 데이터들을 처리하고, 두번째 단계에서 처리된 데이터를 통해 텍스트 or html로 표현하는 것이다.")])]),t._v(" "),a("h4",{attrs:{id:"_6-두-단계로-분리하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-두-단계로-분리하기"}},[t._v("#")]),t._v(" 6) 두 단계로 분리하기")]),t._v(" "),a("ul",[a("li",[t._v("renderPlainText에서는 데이터들을 표현만 해주도록하고 그전에 필요한 데이터들을 세팅해준다. "),a("a",{attrs:{href:"step6.js"}},[t._v("step 6")])])]),t._v(" "),a("h4",{attrs:{id:"_7-반복분을-파이프라인으로-바꾸기-js-분리-후-html-기능-만들기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-반복분을-파이프라인으로-바꾸기-js-분리-후-html-기능-만들기"}},[t._v("#")]),t._v(" 7) 반복분을 파이프라인으로 바꾸기, js 분리 후 html 기능 만들기")]),t._v(" "),a("ul",[a("li",[t._v("각각을 모듈화하였기 때문에 html 버전을 만들 때 코드의 중복없이 깔끔하게 만들 수 있게 되었다. "),a("a",{attrs:{href:"step7"}},[t._v("step 7")])])]),t._v(" "),a("h3",{attrs:{id:"_3-다형성을-활용해-계산-코드-재구성-타입-코드를-서브클래스로-바꾸기-step-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-다형성을-활용해-계산-코드-재구성-타입-코드를-서브클래스로-바꾸기-step-8"}},[t._v("#")]),t._v(" 3. 다형성을 활용해 계산 코드 재구성 (타입 코드를 서브클래스로 바꾸기) "),a("a",{attrs:{href:"step8"}},[t._v("step 8")])]),t._v(" "),a("ul",[a("li",[t._v("연극 장르룰 추가하고 장르마다 공연료와 적립 포인트 계산법을 다르게 지정할 기능을 추가한다면 현재 상태에서는 계산을 수행하는 함수의 조건문을 수정해야 한다.")]),t._v(" "),a("li",[t._v("다형성을 활용하여 상속 계층을 구성해 각 장르별 서브 클래스가 구체적인 계산로직을 정의한다.")]),t._v(" "),a("li",[t._v("이번 수정으로 나아진 점은 연극 장르별 계싼 코드들을 함께 묶은 것이다.")]),t._v(" "),a("li",[t._v("이제 새로운 장르를 추가하려면 해당 장르의 서브 클래스와 생성 함수인 createPerformanceCalculator에 추가하기만 하면된다.")])]),t._v(" "),a("blockquote",[a("p",[t._v("좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가이다.")])]),t._v(" "),a("blockquote",[a("p",[t._v("리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절때 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.")])])])}),[],!1,null,null,null);_.default=v.exports}}]);