<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 2. 리팩터링 원칙 | VuePress Blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <link rel="preload" href="/blog/assets/css/0.styles.9ea36144.css" as="style"><link rel="preload" href="/blog/assets/js/app.0c92ff0b.js" as="script"><link rel="preload" href="/blog/assets/js/5.1f8413b7.js" as="script"><link rel="preload" href="/blog/assets/js/2.b1704ffe.js" as="script"><link rel="preload" href="/blog/assets/js/45.6710fd48.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.0caa0d5a.js"><link rel="prefetch" href="/blog/assets/js/11.002732ff.js"><link rel="prefetch" href="/blog/assets/js/12.0ace2579.js"><link rel="prefetch" href="/blog/assets/js/13.d3320693.js"><link rel="prefetch" href="/blog/assets/js/14.4e862b39.js"><link rel="prefetch" href="/blog/assets/js/15.8392d42f.js"><link rel="prefetch" href="/blog/assets/js/16.2687890e.js"><link rel="prefetch" href="/blog/assets/js/17.b6b151a9.js"><link rel="prefetch" href="/blog/assets/js/18.209d7da2.js"><link rel="prefetch" href="/blog/assets/js/19.fe241b95.js"><link rel="prefetch" href="/blog/assets/js/20.b813602b.js"><link rel="prefetch" href="/blog/assets/js/21.413957c1.js"><link rel="prefetch" href="/blog/assets/js/22.f930ff2c.js"><link rel="prefetch" href="/blog/assets/js/23.f19aeafa.js"><link rel="prefetch" href="/blog/assets/js/24.6ac364bc.js"><link rel="prefetch" href="/blog/assets/js/25.108192b8.js"><link rel="prefetch" href="/blog/assets/js/26.590f88f2.js"><link rel="prefetch" href="/blog/assets/js/27.4a4bd104.js"><link rel="prefetch" href="/blog/assets/js/28.2b9b03c4.js"><link rel="prefetch" href="/blog/assets/js/29.5ff1bf29.js"><link rel="prefetch" href="/blog/assets/js/3.725af588.js"><link rel="prefetch" href="/blog/assets/js/30.d8b26814.js"><link rel="prefetch" href="/blog/assets/js/31.c8b89bb6.js"><link rel="prefetch" href="/blog/assets/js/32.6d64247f.js"><link rel="prefetch" href="/blog/assets/js/33.715ff901.js"><link rel="prefetch" href="/blog/assets/js/34.d9dbd203.js"><link rel="prefetch" href="/blog/assets/js/35.57265f29.js"><link rel="prefetch" href="/blog/assets/js/36.269fb436.js"><link rel="prefetch" href="/blog/assets/js/37.cb258795.js"><link rel="prefetch" href="/blog/assets/js/38.4d5a3d22.js"><link rel="prefetch" href="/blog/assets/js/39.ae52b12f.js"><link rel="prefetch" href="/blog/assets/js/4.40245f46.js"><link rel="prefetch" href="/blog/assets/js/40.7f72fba8.js"><link rel="prefetch" href="/blog/assets/js/41.f10eb0fb.js"><link rel="prefetch" href="/blog/assets/js/42.821c9c42.js"><link rel="prefetch" href="/blog/assets/js/43.89e7af83.js"><link rel="prefetch" href="/blog/assets/js/44.2683f171.js"><link rel="prefetch" href="/blog/assets/js/46.d37f4e3e.js"><link rel="prefetch" href="/blog/assets/js/47.d1c45acf.js"><link rel="prefetch" href="/blog/assets/js/48.ee45f8d6.js"><link rel="prefetch" href="/blog/assets/js/49.d157a92b.js"><link rel="prefetch" href="/blog/assets/js/50.bcfaa4f5.js"><link rel="prefetch" href="/blog/assets/js/51.7bf3ba0e.js"><link rel="prefetch" href="/blog/assets/js/52.328cd456.js"><link rel="prefetch" href="/blog/assets/js/53.1470df17.js"><link rel="prefetch" href="/blog/assets/js/54.d20fce4b.js"><link rel="prefetch" href="/blog/assets/js/55.e059f1d2.js"><link rel="prefetch" href="/blog/assets/js/56.285ebd8c.js"><link rel="prefetch" href="/blog/assets/js/57.f59f5ed5.js"><link rel="prefetch" href="/blog/assets/js/58.ff9dfb2d.js"><link rel="prefetch" href="/blog/assets/js/59.116eb316.js"><link rel="prefetch" href="/blog/assets/js/6.fad10661.js"><link rel="prefetch" href="/blog/assets/js/60.405512d2.js"><link rel="prefetch" href="/blog/assets/js/61.09b3a8cf.js"><link rel="prefetch" href="/blog/assets/js/7.35a07a31.js"><link rel="prefetch" href="/blog/assets/js/8.98f335c9.js"><link rel="prefetch" href="/blog/assets/js/9.4a1e9894.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.9ea36144.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-47eed08e><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="VuePress Blog" class="logo"> <span class="site-name can-hide">VuePress Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/blog/refactoring/.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link">
  Tags
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/blog/refactoring/.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link">
  Tags
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>리팩토링</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/refactoring/ch1.html" class="sidebar-link">Chapter 1. 리팩터링 첫 번째 예시</a></li><li><a href="/blog/refactoring/ch2.html" aria-current="page" class="active sidebar-link">Chapter 2. 리팩터링 원칙</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/refactoring/ch3.html" class="sidebar-link">Chapter 3. 코드에서 나는 악취</a></li><li><a href="/blog/refactoring/ch4.html" class="sidebar-link">Chapter 4. 테스트 구축하기</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_1-리팩터링-정의"><a href="#_1-리팩터링-정의" class="header-anchor">#</a> 1. 리팩터링 정의</h3> <h4 id="명사"><a href="#명사" class="header-anchor">#</a> 명사</h4> <ul><li>소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
<ul><li>1장에서 함수 추출, 조건부 로직 다형성으로 변경하는 것들이 여기에 속한다.</li></ul></li></ul> <h4 id="동사"><a href="#동사" class="header-anchor">#</a> 동사</h4> <ul><li>소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성</li></ul> <blockquote><p>누군가 &quot;리팩터링하다가 코드가 깨져서 며칠이나 고생했다&quot;라고 한다면, 십중팔구 리팩터링 한것이 아니다.</p></blockquote> <ul><li>리팩터링 하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든지 멈출 수 있어야 한다.</li> <li>리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. <strong>단지 목적이 다를 뿐이다.</strong></li> <li>리팩토링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것으로 성능은 나빠질 수도 좋아질 수도 있다.</li></ul> <h3 id="_2-두-개의-모자"><a href="#_2-두-개의-모자" class="header-anchor">#</a> 2. 두 개의 모자</h3> <ul><li>개발 시 목적이 '기능 추가'냐 '리팩터링'인지를 두 개의 모자로 비유 한다.</li> <li>기능 추가 시 기눙 추가 모자를 쓴 후 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.
<ul><li>진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 진행한다.</li></ul></li> <li>리팩터링 시는 기능 추가는 절대 하지 않고 오로지 코드 재구성에 전념한다.
<ul><li>테스드도 새로 만들지 않고 기존 테스트를 실행시킨다.(인터페이스 변경이 필요해지면 테스트 수정이 필요해짐)</li></ul></li></ul> <blockquote><p><strong>작업 시간이 10분이라고 해도 항상 쓰고 있는 모자가 무엇인지, 그에 따른 작업 방식의 차이를 분명하게 인식해야 한다.</strong></p></blockquote> <h3 id="_3-리팩터링하는-이유"><a href="#_3-리팩터링하는-이유" class="header-anchor">#</a> 3. 리팩터링하는 이유</h3> <h4 id="소프트웨어-설계가-좋아진다"><a href="#소프트웨어-설계가-좋아진다" class="header-anchor">#</a> 소프트웨어 설계가 좋아진다.</h4> <ul><li>리팩터링을 하지 않으면 소프트웨어의 내부 설계가 썩기 쉽다.</li> <li>아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.</li> <li><strong>규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.</strong></li></ul> <h4 id="소프트웨어를-이해하기-쉬워진다"><a href="#소프트웨어를-이해하기-쉬워진다" class="header-anchor">#</a> 소프트웨어를 이해하기 쉬워진다.</h4> <ul><li>컴퓨터는 시키는 일을 정확히 하므로 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.</li></ul> <h4 id="버그를-쉽게-찾을-수-있다"><a href="#버그를-쉽게-찾을-수-있다" class="header-anchor">#</a> 버그를 쉽게 찾을 수 있다.</h4> <ul><li>리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.</li> <li>프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점이 분명히 드러나 버그를 놓칠 수 없을 만큼 명확해진다.</li></ul> <h4 id="프로그래밍-속도를-높일-수-있다"><a href="#프로그래밍-속도를-높일-수-있다" class="header-anchor">#</a> 프로그래밍 속도를 높일 수 있다.</h4> <ul><li>리팩터링을 하면 코드의 구조가 개선돼 사실상 프로그래밍 시간을 줄일 수 있다.</li> <li>모듈화가 잘 되어 있으면 필요한 부분만 이해하면 되고, 코드가 명확하면 버그 가능성이 줄어들며 디버깅이 수월해진다.</li> <li>내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.</li> <li>지구력 가설
<ul><li>내부 설계에 심혀을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.</li></ul></li></ul> <h3 id="_4-언제-리팩터링을-해야-할까"><a href="#_4-언제-리팩터링을-해야-할까" class="header-anchor">#</a> 4. 언제 리팩터링을 해야 할까?</h3> <h4 id="_3의-법칙"><a href="#_3의-법칙" class="header-anchor">#</a> 3의 법칙</h4> <ul><li><ol><li>처음엔 그냥 한다.</li></ol></li> <li><ol start="2"><li>비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.</li></ol></li> <li><ol start="3"><li>비슷한 일을 세 번째 하게되면 리팩터링 한다.</li></ol></li></ul> <h4 id="준비를-위한-리팩터링-기능을-쉽게-추가하게-만들기"><a href="#준비를-위한-리팩터링-기능을-쉽게-추가하게-만들기" class="header-anchor">#</a> 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기</h4> <ul><li>리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.</li> <li>이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꿔 다른 작업을 하기가 쉬워질 부분들을 찾는다.</li> <li>버그를 잡을 때도, 오류를 일으키는 코드가 여러곳 퍼져있다면 한 곳으로 합치는 편이 효율적이다.</li></ul> <h4 id="이해를-위한-리팩터링-코드를-이해하기-쉽게-만들기"><a href="#이해를-위한-리팩터링-코드를-이해하기-쉽게-만들기" class="header-anchor">#</a> 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기</h4> <ul><li>코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리패터링할 여지는 없는지 찾아보자.</li> <li>이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없다.</li></ul> <h4 id="쓰레기-줍기-리팩터링"><a href="#쓰레기-줍기-리팩터링" class="header-anchor">#</a> 쓰레기 줍기 리팩터링</h4> <ul><li>코드를 파악하던 중 비효율적으로 구성된 코드들이 있는데 이 작업에 많은 시간을 쏟을 수 없을 때 조금이라도 개선을 하는 것이다.</li> <li>항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.</li> <li><strong>리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다</strong></li></ul> <h4 id="계획된-리팩터링과-수시로-하는-리팩터링"><a href="#계획된-리팩터링과-수시로-하는-리팩터링" class="header-anchor">#</a> 계획된 리팩터링과 수시로 하는 리팩터링</h4> <ul><li>위에서 설명한 리팩터링은 기회가 될 때만 진행한다.</li> <li>리팩터링 일정을 따로 잡지 않고 기능 추가, 버그 해결중에 리팩터링을 진행한다.</li> <li>리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.</li></ul> <blockquote><p>보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.</p></blockquote> <blockquote><p>무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그 후에 수정하자.</p></blockquote> <ul><li>새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길이다.</li> <li>계획된 리팩터링이 무조건 나쁘진 않지만 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.</li></ul> <h4 id="오래-걸리는-리팩터링"><a href="#오래-걸리는-리팩터링" class="header-anchor">#</a> 오래 걸리는 리팩터링</h4> <ul><li>리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간이다.</li> <li>하지만 몇 주씩 걸리는 대규모 리팩터링도 있다. 라이브러리를 새것으로 교체하거나, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내거나 등..</li> <li>리팩터링이 코드를 깨트리지 않는다는 장점을 활용하여 팀 전체가 매달리기 보다, 누구든지 리팩터링해야할 코드와 관련된 작업을 할 때마다 리팩터링을 통해 조금씩 원하는 방향으로 개선하자.</li></ul> <h4 id="코드-리뷰에-리팩터링-활용하기"><a href="#코드-리뷰에-리팩터링-활용하기" class="header-anchor">#</a> 코드 리뷰에 리팩터링 활용하기</h4> <ul><li>가능하면 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링한다. 이렇게 자연스럽게 <strong>짝 프로그래밍</strong>이 된다.</li></ul> <h4 id="리팩터링-하지-말아야-할-때"><a href="#리팩터링-하지-말아야-할-때" class="header-anchor">#</a> 리팩터링 하지 말아야 할 때</h4> <ul><li>외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.</li> <li>내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있따.</li> <li>리팩터링보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링하지 않는다.</li></ul> <h3 id="_5-리팩터링-시-고려할-문제"><a href="#_5-리팩터링-시-고려할-문제" class="header-anchor">#</a> 5. 리팩터링 시 고려할 문제</h3> <h4 id="새-기능-개발-속도-저하"><a href="#새-기능-개발-속도-저하" class="header-anchor">#</a> 새 기능 개발 속도 저하</h4> <ul><li><strong>리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.</strong></li> <li>리팩터링을 '클린 코드', '바람직한 엔지니어링 습관'처럼 도덕적인 이류로 정당화하는게 아닌 오직 경제적인 이유로 하여야 한다.</li> <li>리팩터링은 개발 기간을 단축하고자 하는 것이며 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.</li></ul> <h4 id="코드-소유권"><a href="#코드-소유권" class="header-anchor">#</a> 코드 소유권</h4> <ul><li>코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 코드 소유권은 팀에 두고 팀원 누구나 팀의 코드를 수정할 수 있게 한다.</li></ul> <h4 id="브랜치"><a href="#브랜치" class="header-anchor">#</a> 브랜치</h4> <ul><li>브랜치를 기능별로 분리하여 마스터로 통합하는 방식은 효율적일 수 있지만 리팩터링에는 잘 어울리지 못한다.</li> <li>가능한 통합 주기를 짧게하여 통합 시 코드의 문제 발생을 최대한 적게 하도록 한다.</li></ul> <h4 id="테스팅"><a href="#테스팅" class="header-anchor">#</a> 테스팅</h4> <ul><li>리팩터링은 단계별 변경 폭이 작아 도중에 발생한 오류의 원인이 될만한 코드의 범위가 넓지 않다.</li> <li>원인을 못 찾더라도 기능에 변경은 없으니 이전 버전으로 돌리면된다.</li> <li>오류를 재빨리 잡기 위해 가장 효율적인건 테스트이다. 변경이 잦은 리팩터링을 하기 위해선 테스트가 매우 중요하다.</li></ul> <h4 id="레거시-코드"><a href="#레거시-코드" class="header-anchor">#</a> 레거시 코드</h4> <ul><li>레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.</li> <li>레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다.</li> <li>제 기능이 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬는다.</li> <li>대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.</li> <li>테스트 코드가 없다면 테스트를 보강하자.</li></ul> <h3 id="_6-리팩터링-아키텍처-애그니-yagni"><a href="#_6-리팩터링-아키텍처-애그니-yagni" class="header-anchor">#</a> 6. 리팩터링, 아키텍처, 애그니(YAGNI)</h3> <ul><li>리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.</li> <li>리팩터링은 어느 부분에 유연성이 필요하고 어떻게 잘 대응할지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다.</li> <li>이런식의 설계를 '간결한 설계', '점진적 설계', 'YAGNI(You aren't going to need it) 등으로 부른다.</li> <li>YAGNI를 한다고 선제적인 아키텍처를 소홀히 해도 된다는건 아니다. 다만 이 둘 사이의 균형점이 이전과 크게 달라졌다.</li></ul> <h3 id="_7-리팩터링과-소프트웨어-개발-프로세스"><a href="#_7-리팩터링과-소프트웨어-개발-프로세스" class="header-anchor">#</a> 7. 리팩터링과 소프트웨어 개발 프로세스</h3> <ul><li>익스트림 프로그래밍(XP)의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 상호 의존하는 기법들을 하나로 묶은 프로세스라고 할 수 있다.</li> <li>지속적 통합, 자가 테스트 코드, 리팩터링을 적용하면 YAGNI 설계를 진행할 수 있다. 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다.</li> <li>추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽기 때문이다.</li></ul> <h3 id="_8-리팩터링과-성능"><a href="#_8-리팩터링과-성능" class="header-anchor">#</a> 8. 리팩터링과 성능</h3> <ul><li>직관적인 설계 vs 성능은 중요한 주제다.</li> <li>리팩터링하면 소프트웨어가 느려질 수 있는건 사실이다.</li> <li>하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.</li> <li>hard real-time 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, <strong>먼저 튜닝하기 쉽게 만들고</strong> 나서 원하는 속도가 나게끔 튜닝하는 것이다.</li> <li><strong>그 후 끊임없이 관심을 기울인다.</strong> 프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다.</li> <li>성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발은 더뎌진다.</li> <li>성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다.</li> <li>그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없을 것이므로 시간 낭비인 셈이다.</li> <li>90%의 시간 낭비에 착안하여 성능 개선의 3번째 방법은 <strong>의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.</strong></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/refactoring/ch1.html" class="prev">
        Chapter 1. 리팩터링 첫 번째 예시
      </a></span> <span class="next"><a href="/blog/refactoring/ch3.html">
        Chapter 3. 코드에서 나는 악취
      </a>
      →
    </span></p></div> <div id="disqus_thread" data-v-77dddae1 data-v-47eed08e></div></main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.0c92ff0b.js" defer></script><script src="/blog/assets/js/5.1f8413b7.js" defer></script><script src="/blog/assets/js/2.b1704ffe.js" defer></script><script src="/blog/assets/js/45.6710fd48.js" defer></script>
  </body>
</html>
