---
sidebar: auto
title: JAVA 제네릭 배열을 생성하지 못하는 이유
date: 2020-07-18 14:28
img: java.png
tags: 
    - JAVA
---

- 자바에서 제네릭 배열을 직접 생성하려고 하면 컴파일 에러가 발생합니다.
- 그 이유는 제네릭과 배열의 서로 다른 특징 때문에 제네릭이 사용되는 이유인 **타입 선언을 통한 타입 안정성을 보장해줄 수 없기 때문입니다.**

## 제네릭과 배열의 차이점
### 1. 배열은 공변, 제네릭은 불공변
- 공변성이란 자신의 타입과 자신을 확장한 타입까지 할당 할 수 있음을 의미합니다.
- 불공변성이란 오직 자신의 타입만 가질 수 있음을 의미합니다.
 
#### 배열은 공변성을 가진다.
```java
Object[] objects = new String[1];
objects[0] = 1; // 컴파일은 되지만, 실행시간(런타임)에 예외가 발생한다.
```
- 배열은 공변성을 가지므로 Object타입의 배열은 자신을 확장한 타입인 String타입의 배열로 할당할 수 있습니다.
- objcets 변수는 현재 String 타입의 배열을 참조하고 있지만 Object 배열이기 때문에 Object 타입을 확장한 Integer 타입의 값을 배열의 요소에 할당할 수 있습니다.
- 하지만 실제로 objects는 String 타입의 배열이기 때문에 실행을 해보면 에러가 발생합니다.
- 자바를 사용하는 이유 중 하나가 정적 컴파일 언어로 시스템의 안정성을 높여주기 위함인데 배열의 이러한 특징은 컴파일 타임에 에러를 잡아주지못해 안전하지 않습니다.

#### 제네릭은 불공변성을 가진다.
```java
ArrayList<Object> objectList = new ArrayList<String>(); // 컴파일 에러 발생
```
- 반대로 제네릭은 불공변하기 때문에 String 타입이 Object 타입을 확장했다 하더라도 컴파일 에러가 발생합니다.
- 컴파일이 되지 않기 때문에 배열에 비해 훨씬 더 안전하게 프로그래밍을 할 수 있습니다.

### 2. 배열은 실체화되지만 제네릭은 실체화 불가능하다.

#### 배열은 런타임에 실체화 된다.
```java
Object[] objects = new String[1];
objects[0] = 1; // 컴파일은 되지만, 실행시간(런타임)에 예외가 발생한다.
```
- 배열의 공변성을 설명할때 사용한 코드를 실제로 실행 시 예외를 발생시킬 수 있었던 이유는 **배열은 실체화 되기 때문에 런타임에 자신이 담기로 한 원소타입(String)을 인지할 수 있습니다.**
- 즉 런타임에 objects 배열의 첫 번째 원소에 1을 넣으려고 할 때 objects 배열은 String 배열로 실체화되기 때문에 Integer는 String이 될 수 없으니 예외가 발생합니다. 

#### 제네릭은 런타임에 실체되지 않는다.
```java
// 컴파일 타임(실제 작성한 코드)
ArrayList<String> stringList = new ArrayList<String>();
ArrayList<Integer> integerList = new ArrayList<Integer>();

// 런타임
ArrayList stringList = new ArrayList();
ArrayList integerList = new ArrayList();
```
- 제네릭은 실제 코드에 작성한 것과 다르게 런타임시에는 타입이 실체화되지 않고 소거(Erasure)됩니다.
- 위의 코드와 같이 실제 작성한 코드에는 제네릭의 타입파라미터가 String, Integer로 명시되어 있지만 런타임에는 해당 타입들이 제거된 것을 알 수 있습니다.
    - 이렇게 컴파일타임보다 런타임에 타입 정보를 적게 가지는 타입을 **실체화 불가 타입이라고 합니다.**

#### 왜 제네릭은 실체화 불가능하게 만들었을까?
- 사실 프로그래밍의 안전성 방면에서는 런타임에도 자신의 타입을 가지고 있는게 좋을 것입니다.
- 하지만 자바가 이러한 방식을 추구한 이유는 하위 호환성을 위해서 입니다.
    - 제네릭이 실체화 되도록 만들었다면 제네릭이 생성되기 전에 사용된 코드들과 함께 사용이 불가능 할 것입니다.
- 제네릭이 런타임에 자신의 타입을 소거하더라도 개발자가 선언한 제네릭의 타입 파라미터에 명시한 타입만 들어갈 수 있도록 **타입 안전성을 보장해줘야 합니다.**
- 하지만 배열은 위에서 보았듯이 공변성을 가지기 때문에 제네릭 배열이 가능하도록 하면 타입 안전성을 보장할 수 없게 됩니다.

## 제네릭 배열이 가능하다면 발생할 수 있는 문제점
```java
// 이 코드는 컴파일 에러가 발생하지만 에러가 발생하지 않는다고 가정
ArrayList<String>[] stringLists = new ArrayList<String>[1]; // 제네릭 배열을 생성. 런타임시에는 제네릭 타입은 소거되므로 ArrayList[]가 된다.

ArrayList<Integer> intList = Arrays.asList(1);              // 타입 소거로 인해 런타임시 ArrayList가 된다.
Object[] objects = stringLists;                             // 배열은 공변성을 가지므로 Object[]는 ArrayList[]가 될 수 있다.
objects[0] = intList;                                       // intList또한 ArrayList이므로 배열의 요소가 될 수 있다. 
String s = stringLists[0].get(0)                            // String 타입을 가져야 하지만 Integer이므로 예외 발생  
```
- 만약 제네릭 배열을 만들 수 있다면 위와 같은 상황이 발생할 수 있고 이는 결국 런타임 예외로 이어집니다.
- 코드의 마지막 줄에 stringLists[0]에는 intList가 존재하기 때문에 해당 결과는 Integer를 반환하지만 String 타입을 가져야하므로 Integer -> String으로 형변환을 시도하여 예외가 발생하게 됩니다.
- **이러한 이유로 제네릭 배열은 제네릭의 타입안정성을 보장해줄 수 없어 제네릭 배열을 만들 수 없도록 한 것입니다.**

> 하지만 모든 경우에서 제네릭 배열이 불가능한 것은 아닙니다. 와일드카드 타입을 이용하거나, 강제 형변환을 통해 제네릭 배열을 사용할 수 있습니다.
  
## 제네릭 배열 사용하기
### 와일드카드 타입을 이용한 제네릭 배열 생성 
```java
// 컴파일 에러가 발생 안함.
List<?>[] lists = new List<?>[2];
lists[0] = Arrays.asList(1);
lists[1] = Arrays.asList("A");
    for (List<?> list : lists) {
        System.out.println(list);
    }
}
```
- 비한정적 와일드카드 타입으로 제네릭 배열을 생성하면 컴파일에러가 발생하지 않습니다.
- 비한정적 와일드카드 타입은 모든 제네릭 타입을 가질 수 있습니다. 그러므로 raw 타입으로 정의한 `List[]`와 동일한 의미를 가지므로 컴파일 에러를 발생시키지 않습니다.
    - raw 타입이기 때문에 모든 타입을 포함할 수 있어 배열의 공변성이 문제가 되지 않습니다.

### 형변한 이용하기
```java
public class Store<E> {
    private E[] elements;
    private int index;
    
    // 컴파일 에러가 아닌 경고를 낼 것이지만 타입 안전성을 확신할 수 있으니 경고를 제거한다.
    @SuppressWarnings("unchecked")
    public Store(int size) {
     // this.elements = new E[size]; 제네릭 배열은 생성불가! 컴파일 에러가 발생한다.
        this.elements = (E[]) new Object[size];
        this.index = 0;
    }
    
    public boolean save(E e) {
        if (index >= elements.length)
            return false;
        
        elements[index++] = e;
        return true;
    }
}
```
- Object 배열에서 (E[])로 형변환을 이용하면 제네릭 배열을 만들 수 있습니다.
- 형변환을 통해 제네릭 배열을 생성하는 경우 타입 안전성을 보장해줄 수 없기 때문에 컴파일러에서 경고를 표시할 것입니다.
- 하지만 코드 상으로 save 메서드에서만 값을 넣을 수 있고 해당 메서드 파라미터는 제네릭 타입만 가능하므로 코드상으로 타입 안전성을 보장할 수 있습니다.  
    - 타입 안전함을 확신한다면 애노테이션(@SuppressWarnings) 통해 경고를 지울 수 있습니다.
    
## 결론
- 배열과 제네릭은 서로 다른 특징을 가지고 있습니다.
- 배열은 공변성을 가지며 런타임에 실체화 되어 타입 정보를 가지고 있습니다.
- 제네릭은 불공변성을 가지며 런타임에 타입이 소거 됩니다.
- 배열과 제네릭의 특징의 차이로 인해 이 둘을 함께 사용하게 되면 제네릭이 보장해줘야 하는 타입 안전성을 보장해줄 수 없을 뿐더러 런타임에 오류를 발생시킬 수 있기 때문에 일반적인 제네릭 배열은 생성할 수 없습니다.


