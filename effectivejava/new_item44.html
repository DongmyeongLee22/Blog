<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>아이템 44. 표준 함수형 인터페이스를 사용하라 | VuePress Blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/blog/img/favicon.svg">
    <meta name="description" content="">
    <link rel="preload" href="/blog/assets/css/0.styles.ccd4dff8.css" as="style"><link rel="preload" href="/blog/assets/js/app.00d126d8.js" as="script"><link rel="preload" href="/blog/assets/js/8.93fc2bb7.js" as="script"><link rel="preload" href="/blog/assets/js/4.4e435d8a.js" as="script"><link rel="preload" href="/blog/assets/js/40.ce4fb4e1.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.92166178.js"><link rel="prefetch" href="/blog/assets/js/10.e05f31ab.js"><link rel="prefetch" href="/blog/assets/js/11.736cbf6d.js"><link rel="prefetch" href="/blog/assets/js/12.f3d3168e.js"><link rel="prefetch" href="/blog/assets/js/13.a73f903a.js"><link rel="prefetch" href="/blog/assets/js/14.178272cc.js"><link rel="prefetch" href="/blog/assets/js/15.99445dfd.js"><link rel="prefetch" href="/blog/assets/js/16.28a3d4dc.js"><link rel="prefetch" href="/blog/assets/js/17.8bdc665f.js"><link rel="prefetch" href="/blog/assets/js/18.acf4ae0d.js"><link rel="prefetch" href="/blog/assets/js/19.8d7b204e.js"><link rel="prefetch" href="/blog/assets/js/2.f2b50b7a.js"><link rel="prefetch" href="/blog/assets/js/20.44a1f72d.js"><link rel="prefetch" href="/blog/assets/js/21.4f37b9be.js"><link rel="prefetch" href="/blog/assets/js/22.1e50e0e9.js"><link rel="prefetch" href="/blog/assets/js/23.4fce1ac0.js"><link rel="prefetch" href="/blog/assets/js/24.16049206.js"><link rel="prefetch" href="/blog/assets/js/25.30dc6d75.js"><link rel="prefetch" href="/blog/assets/js/26.6b2169a5.js"><link rel="prefetch" href="/blog/assets/js/27.ddefb206.js"><link rel="prefetch" href="/blog/assets/js/28.9024fe3f.js"><link rel="prefetch" href="/blog/assets/js/29.49bd38af.js"><link rel="prefetch" href="/blog/assets/js/30.618fb1d0.js"><link rel="prefetch" href="/blog/assets/js/31.f30c0699.js"><link rel="prefetch" href="/blog/assets/js/32.211dc8b4.js"><link rel="prefetch" href="/blog/assets/js/33.fcec6aad.js"><link rel="prefetch" href="/blog/assets/js/34.7620d3dc.js"><link rel="prefetch" href="/blog/assets/js/35.b6b78c40.js"><link rel="prefetch" href="/blog/assets/js/36.b6cb6ebe.js"><link rel="prefetch" href="/blog/assets/js/37.62311253.js"><link rel="prefetch" href="/blog/assets/js/38.5af748b9.js"><link rel="prefetch" href="/blog/assets/js/39.39a41e1c.js"><link rel="prefetch" href="/blog/assets/js/41.506564b8.js"><link rel="prefetch" href="/blog/assets/js/42.3b34200b.js"><link rel="prefetch" href="/blog/assets/js/43.7cd0887e.js"><link rel="prefetch" href="/blog/assets/js/44.bdf33fbe.js"><link rel="prefetch" href="/blog/assets/js/45.4e77adb5.js"><link rel="prefetch" href="/blog/assets/js/46.1d02de74.js"><link rel="prefetch" href="/blog/assets/js/47.16225947.js"><link rel="prefetch" href="/blog/assets/js/48.d1fdf786.js"><link rel="prefetch" href="/blog/assets/js/49.921496cf.js"><link rel="prefetch" href="/blog/assets/js/5.085f0de2.js"><link rel="prefetch" href="/blog/assets/js/50.aeb6b47e.js"><link rel="prefetch" href="/blog/assets/js/51.7e033947.js"><link rel="prefetch" href="/blog/assets/js/52.0a226ff6.js"><link rel="prefetch" href="/blog/assets/js/53.955848c7.js"><link rel="prefetch" href="/blog/assets/js/54.1a7eacc4.js"><link rel="prefetch" href="/blog/assets/js/55.ebe70ee7.js"><link rel="prefetch" href="/blog/assets/js/56.9d71b1ee.js"><link rel="prefetch" href="/blog/assets/js/57.a10970a1.js"><link rel="prefetch" href="/blog/assets/js/58.e996690e.js"><link rel="prefetch" href="/blog/assets/js/59.602f4ebb.js"><link rel="prefetch" href="/blog/assets/js/6.c8e90f25.js"><link rel="prefetch" href="/blog/assets/js/60.eae17f6c.js"><link rel="prefetch" href="/blog/assets/js/61.ca25876c.js"><link rel="prefetch" href="/blog/assets/js/62.8ca5b123.js"><link rel="prefetch" href="/blog/assets/js/63.12a73bd9.js"><link rel="prefetch" href="/blog/assets/js/7.f4c9f389.js"><link rel="prefetch" href="/blog/assets/js/9.238a8554.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ccd4dff8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-0d5cbc4c><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="VuePress Blog" class="logo"> <span class="site-name can-hide">VuePress Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/blog/effectivejava/.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link">
  Tags
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/java/" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/blog/effectivejava/.html" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link">
  Tags
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><ul><li>자바가 람다를 지원하면서 API를 작성하는 모범 사례도 크게 바뀌었다.</li> <li>상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴의 매력이 크게 줄었다.</li> <li>이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩터리나 생성자를 제공하는 것이다.</li> <li>즉 함수형 매개변수를 많이 받아야 하므로 함수형 매개변수 타입을 올바르게 선택해야 한다.</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>LinkedHashMap에서는 위의 메서드 조건이 맞으면 새로운 키가 추가될 때 가장 오래된 키를 제거하는 메서드를 제공한다.</li> <li>현재 이를 다시 구현한다면 함수객체를 정적 팩터리나 생성자로 받아 이를 구현하였을 것이다.</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">interface</span> <span class="token class-name">EldestEntryRemovalFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>이러한 함수형 인터페이스를 매개변수로 받으면 될 것이다.</li> <li>이렇게 직접 구현하여도 되지만 자바 표준에는 약 40여개의 함수형 인터페이스를 제공하므로 <strong>필요한 용도에 맞는게 있다면 직접 구현하지말고 표준 함수형 인터페이스를 활용하자.</strong></li> <li>제공해주는 인터페이스를 사용하면 API를 다루는 개념의 수도 줄어들고 default 메서드로 제공해주는 기능들을 사용할 수 있기 때문에 상호 운용성이 더 좋아질 것이다.</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">.</span><span class="token class-name">Map</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function</span><span class="token punctuation">.</span><span class="token class-name">BiPredicate</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
  <span class="token class-name">BiPredicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> biPredicate<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>BiPredicate를 이용하면 위의 인터페이스와 동일한 기능을 구현할 수 있다.</li> <li>40여개의 함수형 인터페이스를 모두 기억하진 말고 기본 인터페이스 6개만 기억후 나머지는 이를 통해 유추할 수 있다.</li></ul> <h4 id="operator"><a href="#operator" class="header-anchor">#</a> Operator</h4> <ul><li>Operator 인터페이스는 인수가 1개인 UnaryOperator, 인수가 2개인 BinaryOperator로 나뉘며 <strong>반환값과 인수가 같은 함수를 뜻한다.</strong></li></ul> <h4 id="predicate"><a href="#predicate" class="header-anchor">#</a> Predicate</h4> <ul><li>인수를 받아 boolean을 반환하는 함수이다.</li></ul> <h4 id="function"><a href="#function" class="header-anchor">#</a> Function</h4> <ul><li>인스와 반환 타입이 다른 함수이다.</li></ul> <h4 id="supplier"><a href="#supplier" class="header-anchor">#</a> Supplier</h4> <ul><li>인수를 받지 않고 오직 반환만을 제공하는 함수이다.</li></ul> <h4 id="consumer"><a href="#consumer" class="header-anchor">#</a> Consumer</h4> <ul><li>인수를 하나 받고 반환값이 없는 함수를 뜻한다.</li></ul> <h4 id="기본타입-함수형-인터페이스"><a href="#기본타입-함수형-인터페이스" class="header-anchor">#</a> 기본타입 함수형 인터페이스</h4> <ul><li>int, double, long에 대한 기본타입 인터페이스를 제공한다.</li> <li>IntPredicate, LongBinaryOperator 등이 있다.</li> <li>Function 인터페이스는 LongToIntFunction, ToLongFunction&lt;T&gt;, ToIntBiFunction&lt;T, U&gt; 등을 제공한다.</li> <li>Supplier를 제외한 기본 함수형 인터페이스는 BiFunction, BiPredicate, BiConsumer를 제공한다.</li> <li>Consumer는 ObjDoubleConsumer&lt;T&gt;, ObjIntConsumer&lt;T&gt;등도 제공한다.</li> <li><strong>기본 함수형 인터페이스에 박싱된 기본 타입을 사용하지 말자. 성능의 문제가 발생하기 쉽다.</strong></li></ul> <h4 id="직접-정의가-필요할-때"><a href="#직접-정의가-필요할-때" class="header-anchor">#</a> 직접 정의가 필요할 때</h4> <ul><li>대부분의 상황에서는 직접 작성하는 것보다 표준 함수형 인터페이스를 사용하는 편이 낫다.</li> <li>하지만 기본 함수형인터페이스에서 제공해주지 않을 경우는 직접 구현이 필요하다.</li> <li>그리고 Comparator&lt;T&gt;는 사실 ToIntBiFunction&lt;T, U&gt;와 동일하다.</li> <li>하지만 Comparator는 독자적인 인터페이스로 살아남아야 한다.</li> <li>먼저 API에서 굉장히 자주사용되는데 해당 클래스 이름은 용도를 잘 설명해주고 있다.</li> <li>두 번째, 구현하는 쪽에서 반드시 지켜야할 규약을 담고 있다.</li> <li>세 번째, 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드들을 듬뿍 담고 있다.</li></ul> <h4 id="표준-함수형-인터페이스가-존재하더라도-직접-구현이-필요한-경우"><a href="#표준-함수형-인터페이스가-존재하더라도-직접-구현이-필요한-경우" class="header-anchor">#</a> 표준 함수형 인터페이스가 존재하더라도 직접 구현이 필요한 경우</h4> <ul><li>자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.</li> <li>반드시 따라야 하는 규약이 존재한다.</li> <li>유용한 디폴트 메서드를 제공할 수 있다.</li></ul> <h4 id="functionalinterface-애너테이션을-사용하라"><a href="#functionalinterface-애너테이션을-사용하라" class="header-anchor">#</a> @FunctionalInterface 애너테이션을 사용하라</h4> <ul><li>해당 애노테이션은 람다용을 설계된 것임을 명시적으로 알려준다.</li> <li>추상 메서드를 오직하나만 존재하여야 컴파일이 되므로 누군가 실수로 추상 메서드를 추가하는걸 막아준다.</li></ul> <h4 id="주의-사항"><a href="#주의-사항" class="header-anchor">#</a> 주의 사항</h4> <ul><li><strong>서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안된다.</strong></li> <li>ExecutorService의 submit 메서드는 Callable&lt;ㅅT&gt;를 받는 것과 Runnable을 받는 것을 다중 정의했다.</li> <li>그래서 올바른 메서드를 알려주기 위하여 형변호나을 해야할 때가 종종 생긴다.</li> <li>이를 피하기 위해서는 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 다중정의를 피하자.</li></ul> <h4 id="핵심-정리"><a href="#핵심-정리" class="header-anchor">#</a> 핵심 정리</h4> <ul><li>함수형 인터페이스를 사용할 때 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 활용하자.</li> <li>상황에 따라 직접 구현이 필요할 때 직접 만들어 사용하자.</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> <div id="disqus_thread" data-v-77dddae1 data-v-0d5cbc4c></div></main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.00d126d8.js" defer></script><script src="/blog/assets/js/8.93fc2bb7.js" defer></script><script src="/blog/assets/js/4.4e435d8a.js" defer></script><script src="/blog/assets/js/40.ce4fb4e1.js" defer></script>
  </body>
</html>
